# Git
Allows you to share files- optimized for code. 
*Version control* allows you to record snapshots of a project, allowing you go back to earlier versions.  

## How does it work?
<img src="https://www.git-tower.com/learn/git/ebook/en/command-line/remote-repositories/introduction/basic-remote-workflow.png" style="zoom:40%;"/>

The repository is a database of code snapshots called "commits". 

Local repository contains the files on your machine that you are working with on your text editor. When you confident in your changes, you can create create a commit that adds your modifications to your git history. 
- Local repositories are private to one user's account
- If you can't log into the computer, you can't access it.

The remote repository is on a server makes the commits available to anyone with access. Can act as a backup

Information abou changes in a copy of the repo is stored across several non-human-readable files in a subdirectory called `.git` which is created when you clone a repo. 
- `.git/config` might be helpful. 

## Commands
Full list of commands [here](https://education.github.com/git-cheat-sheet-education.pdf)
`git add <file>`: add to the project ("stage a file" so that it will be part of the commit).
`git commit -m "commit message"`: update local repo to include changes since last commit ("take a local scnapshot"). 
`git push`: send changes fromlocal repo to remote repo (on github)
`git status`: check what's been modified or staged.
`git mv <file> <file>`: rename a file since plain-old `mv` or `rm` don't work.
`git rm <file>`: remove a file. 

`git pull`: local repo asks for most updated copy from remote repo.
`git push`: local repo sends all recent commits up to remote repo.
*Conflicts* can occur from these two commands
- on `git pull`, your local has changes which conflict with changes to the same file(s) in the remote repo (merge conflict).
- on `git push`, the remote repo has commits you don't have in your local repo (non-fast-forward update).

`git clone <repository-url>` transfers files from remote repo to local machine.
## Tracked Files
Files that are part of your project (git add'ed them) are called *tracked*.
Tracked files can be of in the following states:
- Unmodified (same as copy in local repo).
- Modifed (differet from copy in local repo but not yet staged).
- Staged (next `git commit` will update the repo).
When you...
- edit files: unmodified -> modified
- do `git add`: modified -> staged
- do`git commit`: staged -> unmodified.

## Untracked Files
Files that are *not yet* part of your project ("unstaged") are called *untracked*. When you create a new filed, it's *unstaged* until you `git add` it. These *unstaged* files are noticed by git and appear as unstaged when you check `git status`.

If you don't want to include some untracked files, tell git to ignore a file by adding it to `.gitignore` file. 
- Example of things you don't want to include are: `a.out`, `gitlog.txt`, or anything generated by the compiler (executables, .`.o` files).

## Workflow
1. Start each session with `git pull`, to ensure your local copy is up-to-date. 
2. After you complete work on a small task, `commit` it.
3. Include a message with every commit to explain what changes you commited with `-m`.
4. `commit` and `push` before the end of each work session.
5. See a record of your latest commits with `git log`.

### Commit git command orders
1. `git pull` before you  start working.
2. `git add <files you edited>` after you've finished your edit.
3. `git commit -m <comments>` to commit changes with *comments*.
4. `git pull` one more time to sync with new updates.
5. Solve conflicts, then repeat steps 2-5.
6. `git push` back to the repo. 